Object 

let testObj = {};
console.log(typeof testObj); // -> object

this time by defining an object containing two fields with keys nr and str.

let testObj = {
    nr: 600,
    str: "text"
};
console.log(testObj.nr); // -> 600
console.log(testObj.str); // -> text
We can both read and modify the value associated with a particular key. 
What is more, we can also modify the whole object by adding a new, previously non-existent property
console.log(user2.phone); // -> undefined
user2.phone = "904-399-7557";
console.log(user2.phone); // -> 904-399-7557
If you can add new fields to an existing object, can you also delete them? Of course you can: the delete operator is used for this.
console.log(user2.phone); // -> 904-399-7557
delete user2.phone;
console.log(user2.phone); // -> undefined

Array : 

An array, like an object, is a complex data type that can be used to store a data collection. Similar to an object, the stored data (the values) can be of any type. 
The difference between these structures is that in an array we only store values, without the associated names (i.e. the keys).
We know it because the elements of the array are ordered
The easiest way to create arrays in JavaScript is to use square brackets (it’s an array literal).

let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
console.log(days[0]); // -> Sun
console.log(days[2]); // -> Tue
console.log(days[5]); // -> Fri

days[0] = "Sunday";
console.log(days[0]); // -> Sunday

let emptyArray = [];
console.log(emptyArray[0]); // -> undefined

let animals = [];
console.log(animals[0]); // -> undefined

animals[0] = "dog";
animals[2] = "cat";

console.log(animals[0]); // -> dog
console.log(animals[1]); // -> undefined
console.log(animals[2]); // -> cat
e have already said, an array element can be of any type
let names = [["Olivia", "Emma", "Mia", "Sofia"], ["William", "James", "Daniel"]];
console.log(names[0]); // -> ["Olivia", "Emma", "Mia", "Sofia"]
console.log(names[0][1]); // -> Emma
console.log(names[1][1]); // -> James

let femaleNames = names[0];
console.log(femaleNames[0]); // -> Olivia
console.log(femaleNames[2]); // -> Mia
let users =[ 
    {
        name: "Calvin",
        surname: "Hart",
        age: 66,
        email: "CalvinMHart@teleworm.us"
    },
    {
        name: "Mateus",
        surname: "Pinto",
        age: 21,
        email: "MateusPinto@dayrep.com"
    }
];

console.log(users[0].name); // -> Calvin
console.log(users[1].age); // -> 21


To speak quite generally, in JavaScript, everything except primitives is an object. Arrays are also treated as a special kind of object. 
The typeof operator does not distinguish between object types (or more precisely, classes)

 we would like to make sure that the variable contains an array, we can do it using the instanceof operator,
 let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
let day = "Sunday";

console.log(typeof days); // -> object
console.log(typeof day); // -> string

console.log(days instanceof Array); // -> true
console.log(day instanceof Array); // -> false

The instanceof operator is a two-argument operator, which requires the tested variable (or literal) and object class to be specified. 
In our case, the class isArray. The operator returns true or false, depending on the test result.

The length property is used to get information about the length (the number of elements) of the array (including empty positions between existing elements).
let names  = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.length); // -> 4

names[5] = "Amelia";
console.log(names.length); // -> 6

console.log(names); // -> ["Olivia", "Emma", "Mateo", 
"Samuel", undefined, "Amelia"]
console.log(names[3]); // -> Samuel
console.log(names[4]); // -> undefined
console.log(names[5]); // -> Amelia

indexOf :
The indexOf method is used to search the array to locate a given value. If the value is found (the element is in the array), its index (position) will be returned. The method returns -1 if the element is not found. 
If there is more than one element with the same value in the array, the index of the first element is returned.
push
The push method places the element given as its argument at the end of the array. The length of the array is increased by 1, and the new element is inserted on the right (it has the largest index of all elements).
let names = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.length); // -> 4

names.push("Amelia");
console.log(names.length); // -> 5
console.log(names); // - > ["Olivia", "Emma", "Mateo", 
"Samuel", "Amelia"]

The unshift method works similarly to push, the difference being that a new element is added to the beginning of the array. The array length is increased by 1, all the old elements are moved to the right and the new element is 
placed in the empty space that has been created at the beginning of the array. The index of the new element is 0.

The pop method allows you to remove the last element from the array. 
As a result of its execution, the element with the largest index is returned, 
while at the same time it is removed from the original array. The length of the array is obviously reduced by 1.

shift
The shift method works similarly to pop, only this time we remove the element from the beginning of the array (with the index 0). The removed element is returned by the method, all other elements are shifted to the left, 
completing the empty space. The length of the original array is reduced by 1.

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
console.log(names.length); // -> 4

let name = names.shift();
console.log(names.length); // -> 3
console.log(name); // -> Olivia
console.log(names); // -> ["Emma", "Mateo", "Samuel"]

The reverse method reverses the order of elements in the array. As a result of its calling, the first element of the original array will become the last, the second last but one, and so on.

let names = ["Olivia", "Emma", "Mateo", "Samuel"];

names.reverse();
console.log(names); // -> ["Samuel", "Mateo", "Emma",
 "Olivia"]
 

slice
The slice method allows you to create a new array from selected elements of the original array. Calling the method does not affect the original array. The method takes either one or two integer values as arguments.

The basic combinations are:

one argument larger than zero – all elements from the index given as an argument to the end of the array are copied;
two arguments larger than zero – the element from the index specified as the first argument to the element specified as the second argument are copied;
two arguments, first positive, second negative – all elements from the specified index to the end of the array are copied, except for the specified number of the last elements (e.g. argument -3 means that we do not copy the last three elements)
one negative argument – the specified number of the last elements are copied to the end of the array (e.g. -2 means that you copy the last two elements).

let names = ["Olivia", "Emma", "Mateo", "Samuel"];

let n1 = names.slice(2);
console.log(n1); // -> ["Mateo", "Samuel"]

let n2 = names.slice(1,3);
console.log(n2); // -> ["Emma", "Mateo"]

let n3 = names.slice(0, -1);
console.log(n3); // -> ["Olivia", "Emma", "Mateo"]

let n4 = names.slice(-1);
console.log(n4); // -> ["Samuel"]

console.log(names); // -> ["Olivia", "Emma", "Mateo","Samuel"]


The concat method creates a new array by attaching elements from the array given as an argument to the original array elements. 
The method changes neither the original array nor the array specified as an argument.

let names = ["Olivia", "Emma", "Mateo", "Samuel"];
let otherNames = ["William", "Jane"];
let allNames = names.concat( otherNames);

console.log(names); // -> ["Olivia", "Emma", "Mateo","Samuel"]
console.log(otherNames); // -> ["William", "Jane"]
console.log(allNames); // -> ["Olivia", "Emma", "Mateo","Samuel", "William", "Jane"]
