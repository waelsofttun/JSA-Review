let n = 0;
while(n < 91) {
    console.log(n); // -> 0, 10, 20, 30, 40, 50, 60, 70, 80, 90
    n += 10;
}

do {
    code block
} while(condition);

for (initialization; condition; increment) {
    block of code
}

loop initialization statement;
loop condition statement;
loop increment statement.

The for loop initialization statement
The initialization statement is executed only once, before the first loop iteration. Usually, it’s used to initialize (or declare and initialize) a variable that will be used as a loop counter. We can use any existing variable as a counter, but in general it’s good practice to declare a new one, as this makes the code cleaner and easier to read and understand.
The initialization statement is optional and can be left empty, except for ending with a semicolon.


A condition statement is an expression that is evaluated to a Boolean before each loop iteration.
The for loop increment statement : 
and most of the time it’s used to increment (or decrement, depending on the need) a loop counter that is used in a condition statement.
It can be any expression, not only incrementation/decrementation.

for (let i = 0; i < 10; i++) {
    console.log(i);
}
for (let i = 0; i < values.length; i++) {
    console.log(values[i]); // -> 10, 30, 50, 100
}

for (let i = values.length - 1; i > 0; i--) {
    console.log(values[i]); // -> 100, 50, 30, 10
}

for (let i = 0; i < values.length; i += 2) {
    console.log(values[i]); // -> 10, 50

////////////////////for … of ////////////////////
In addition to the regular for loop, there are two specific versions, one of which, for ... of, is dedicated for use with arrays (and other iterative structures, which are however beyond the scope of this course). In a loop of this type, we do not explicitly specify any conditions or number of iterations, as it is performed exactly as many times as there are elements in the indicated array.

let values = [10, 30, 50, 100];
let sum = 0;
for (let number of values) {
    sum += number;
}
console.log(sum); // -> 190

/////////////////////// For in //////////////////
There is also a version of the for loop that enables us to walk through object fields. This is a for ... in construction. It iterates through all fields of the indicated object
let user = {
    name: "Calvin",
    surname: "Hart",
    age: 66,
    email: "CalvinMHart@teleworm.us"
};

for (let key in user) {
    console.log(key); // -> name, surname, age, email
};

 In order to get access to the specified field, we use dot notation (the part of the course dedicated to data types) that is, after the name of the object, we write a dot and the field name (key). The key given in this notation is always treated as a literal. In the for ... in loop, this approach will not work, because the field name (key) is placed in a variable. Fortunately, we have an alternative solution, bracket notation. It allows you to refer to the selected object field using brackets (like in arrays). In the square bracket behind the object name, we place the field name, which can be either a literal or a variable containing that name.

for (let key in user) {
    console.log('${key} -> ${user[key]}');
};

 The break and continue statements

 The break statement is used to terminate the execution of a loop or a switch statement.
 In each of these contexts, whenever the JavaScript engine encounters a break statement, 
 it exits the whole loop or switch statement . 

continue can be used in loops (but not in the switch statement). When used, it applies to the closest surrounding loop. The continue statement, in contrast to break, does not end the whole loop, but rather starts the next iteration of this loop. We can think of it as jumping right to the end of the current iteration.

break is so important in the switch case
In the example, the break keyword is present in all cases except in the default case. In contrast to if statements, switch statements do not execute just one branch, but rather they execute the entire code from the first case that matches until the end of the switch statement. This behavior is called pass-through and has some uses
The fall-through can be useful when more than one case should end with exactly the same behavior.

switch (gate) {
    case "a":
    case "A":
    case 1:
    case "1":
        alert("Gate A: empty");
        break;
    case "b":
    case "B":
    case 2:
    case "2":
        alert("Gate B: main prize");
        win = true;
        break;
    case "c":
    case "C":
    case 3:
    case "3":
        alert("Gate C: empty");
        break;
    default:
        alert("No gate " + String(gate));
}

