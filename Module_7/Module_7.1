*****************Objects – What is an object?**********************

Note that typeof returns the name of the data type as a string.
arrays in JavaScript are also objects. In JavaScript, even functions are objects. In fact, everything in JavaScript, except a primitive, is an object.
----An object as a different type of array-------
A key is simply a label (a name), which is unique within an object and unambiguously defines the selected element.
In objects, we call their component elements properties. Each property will consist of a key (or label) and a value.
As we’ll see later in the course, JavaScript allows you to create objects in many different ways. The easiest way is to use curly brackets.
literal notation == initializer notation 
let sampleObject = {
    id: 10, 
    delay: 20,
    name: "en to tre",
    isPresent: true,
    delay: 50
};

We can modify an object created in this way by, among other things, adding new properties.(dot notation)
sampleObject.newkey= value

The key is a string. When creating an object, the key can be enclosed in quotation marks, although this is not necessary 
(JavaScript automatically interprets it as a string). However,this can be useful when you want to create a key consisting of several words. For example, 
the following construction will be wrong:
//error
let contact = {
	first name: "Ronald"
};
//correct
let contact = {
    "first name": "Ronald"
};

However, giving keys names consisting of many separate words is not the best idea.

If you need a multi-word name, it’s better to use, for example, the Camel case notation, and write firstName instead of "first name". 
The notation will be both more readable to the user and less burdensome on the computer. With multi-word keys, 
it will also be a problem to refer to the property of an existing object – dot notation does not allow it.
bracket notation is the solution for this
the object property does not have to be of the number, Boolean, or string type. It could as easily be an array, an object, or a ... function. 
*************Deleting objects************
The JavaScript engine uses a Garbage Collector, which decides for us whether the objects are still needed, and possibly removes them.

The JavaScript language doesn’t even provide for the possibility of explicitly deleting objects.

**************Properties*********************
---------Types : 
As we mentioned earlier, we can assign primitive values to variables (e.g. number, Boolean, or string), complex values such as arrays or objects, and functions.
let test = {
nr: 10, 
b: false, 
str: "uno dos tres", 
arr: [10, 20, 30], 
obj: {
x: 10, 
y: 20
}, 
fn: function(arg) {console.log(arg)} 
};

test.fn(123);

----------Nested properties : 
If the property of an object is another object that has properties itself, then we are dealing with nested properties.
Referring to such fields using dot notation is intuitive, and we simply add another dot and key (property name).
console.log(test.obj.x);
test.obj.y = 40;
-----------A function as a property type – a method
A function that is the property of an object will be called a method.
Just as the properties of objects describe their characteristics, methods can be treated as their characteristic behavior, or ways of changing the state of an object.

let point = {
x: 0,
y: 0,
moveHorizontally: function(distance) {
    this.x = this.x + distance;
},
moveVertically: function(distance) {
    this.y = this.y + distance;
}
}

console.log(point.x);	// -> 0
point.moveHorizontally(30);
console.log(point.x);	// -> 30

The method does not have to affect the state of the object, but this is essentially one of the main reasons for their use.

----------------Adding a new property

The changes concern not only the values stored in specific fields, but also all the properties that we can add or delete, and the type of data placed in them that we can change.

let contact = {
    tel: "207-662-5412",
    email: "RonaldSMurphy@freepost.org"
};
contact.firstName = "Ronald";
contact.lastName = "Murphy";
console.log(contact.tel);   // -> 207-662-5412
console.log(contact.firstName);     // -> Ronald

By the way, try to display a non-existent property, such as a notes. Note that a non-existent property of an object is treated as undefined and not, for example, as null.(no referernce error)

----------------Modifying a property

By default, there are no restrictions on modifying the values placed in object properties (we’ll talk about non-writable properties in the chapter on configuring object properties).

Thus, we can assign a new value of any type to an existing object property at any time – we are not limited by the previous value type.
contact.email = ["RonaldSMurphy@freepost.org", "rsmurphy@briazz.com" ];

-------------------Deleting a property
delete contact.email.work;
--------------------Dot notation vs. bracket notation
his method is similar to referencing an array field, except that we don't give the index of an element, but instead we give its key. Remember, the key is a string!

contact.tel === contact["tel"];
contact.email.work === contact["email"]["work"]
Multi-word keys => use Bracket notation

-----------------Computed keys
However, bracket notation is more often used when operating on computed keys.

It may happen that the property key we want to refer to will be calculated during the operation of the program, on the fly.

In this case, dot notation will not allow us to combine the object name and calculated key (e.g. stored in a variable).
let contact = {
    email_1: "RonaldSMurphy@freepost.org",
    email_2: "rsmurphy@briazz.com"
};
for(i=1; i<=2; i++) {
    let key = "email_" + i;  //computed key
    console.log(key);
    console.log(contact[key]);

---------------Property existence test and property enumeration
If you try to read a non-existent property, the undefined value will be returned.

JavaScript will behave the same if the field exists but has no value assigned to it.
In most cases, it won’t matter to us whether a field does or does not exist, or simply has no value assigned to it.

Both cases are handled in the same way, with a new value being assigned to the property (if the field does not exist, it will automatically be created).
if(contact.notes) { // if different then undefined
    console.log(contact.notes);
}
 This can have fatal consequences, especially for nested objects.
 console.log(contact.notes); // -> undefined  program continue to work 
 console.log(contact.email.private); // exception! (use try catch)
 
The easiest way to protect yourself is to either use the try ... catch block, or simply check before calling if the object and required field exist:
if(contact && contact.email) {
    console.log(contact.email.private);
}

or 
contact && contact.email && console.log(contact.email.private);

-----------Existence test using "in"
If the field exists, it’s returned true (even if the field has no set value).
if("notes" in contact) { // if true
    console.log(contact.notes);
}
------------Enumeration "for ... in"

Using for ... in, we can go through the properties of an object (with some limitations, which we’ll talk about in the chapter on the configuration of properties).
To get to the value of a given field, we use bracket notation (the key is dynamically calculated and placed in the variable, so we cannot use dot notation).


--------The Object.keys method 
This method returns an array of property names, which we can use in any way we want.
let keys = Object.keys(contact);
---------------The const object can be modified;
const contact = {};
contact = { email: "RonaldSMurphy@freepost.org"}; // TypeError: Assignment to constant variable.
const contact = {};

contact.email = "RonaldSMurphy@freepost.org";
console.log(contact.email);// RonaldSMurphy@freepost.org => no problem

It turns out that not only is no exception generated, but the object is extended with a new field to which the value is assigned.

This value can later be easily modified or deleted.

According to JavaScript documentation, "a constant cannot change through re-assignment" and "a constant cannot be re-declared".

In the case of complex types (i.e. arrays and objects) variables and constants (the var, let, const keywords) do not contain the entire object. They only contain the object reference. For the sake of simplicity, we can imagine the reference as an address indicating where the object is really stored.
So, the const keyword protects only the reference, the address, from change. We cannot change the reference, e.g. by replacing the object (the new object has a different address). However, changes inside an object – adding a new property, changing a value, etc. – do not affect the reference.


In the case of objects, const is designed to protect against a re-declaration or assignment of a new object.

There are, of course, methods to protect objects, or more precisely their properties, from changes.

These will be discussed in the chapter on property configuration.


------------Comparing objects 

As you probably expect, the result of the comparison will be false. The comparison concerns the references of two independent objects.

var point1 = {x: 10, y: 20};
var point2 = {x: 10, y: 20};

console.log(point1 === point2);     // false (we are comparing adresses)

let point3 = point1;

console.log(point1 === point3);     // true

point3.z = 40;

console.log(point3.z);  // 40
console.log(point1.z);  // 40
console.log(point2.z);  // undefined


Using a reference stored in point3, we modify the object by adding a z field to it. The change is visible in the point3 and point1 variables, because they contain references to the same object. On the other hand, point2 points to a different object, and the action taken on point3 has no effect on it.

JavaScript does not have a ready-to-use mechanism to compare two objects by their properties (called deep comparison).
---------------------------Coping objects (coping references (), cloning, merging)

As we checked a moment ago, assigning an object from one variable to another only creates a copy of the reference. But what if we want to copy the contents of the object?

We can use the Object.assign method for this. The method takes the target object as the first argument, to which the fields from other objects will be copied. The second and subsequent arguments (there is no limit to the number of objects) will be used as the source of the properties to be copied. If a property with the same name as the source object already exists in the target object, it will be overwritten with a new value (the target is overwritten with the source).

let point0 = {x:10, y: 20 };
let point1 = point0;    // copy reference
let point2 = {};
Object.assign(point2, point0);  //  copy properties into the new object

console.log(point2.x);
console.log(point2.y);
console.log(point1 === point0); // true
console.log(point1 === point2); // false

let point3 = {};
Object.assign(point3, point0, {z: 100});
console.log(point3.z);

var point4 = {};
Object.assign(point4, point3, {z: 200, color: "red"});

console.log(point4.z);  // 200

As we indicated earlier, in this case, the value from the last, most right-handed argument "wins".

The Object.assign function returns a reference to the target object that has been modified, so we can simplify our example by giving as the first argument (and without much thought) an empty object to which we assign the reference to a variable after completing the Object.assign method.


let point0 = {x:10, y: 20 };
let point2 = Object.assign({}, point0);
let point3 = Object.assign({}, point0, {z: 100});

A convenient alternative to Object.assign is to use the spread operator. There are some differences in the operation of both mechanisms, but they’re so subtle that we won’t bother with them at the moment.
let point0 = {x:10, y: 20 };
let point2 = { ...point0};
let point3 = { ...point0, z: 100};

