*****************Objects – What is an object?**********************

Note that typeof returns the name of the data type as a string.
arrays in JavaScript are also objects. In JavaScript, even functions are objects. In fact, everything in JavaScript, except a primitive, is an object.
----An object as a different type of array-------
A key is simply a label (a name), which is unique within an object and unambiguously defines the selected element.
In objects, we call their component elements properties. Each property will consist of a key (or label) and a value.
As we’ll see later in the course, JavaScript allows you to create objects in many different ways. The easiest way is to use curly brackets.
literal notation == initializer notation 
let sampleObject = {
    id: 10, 
    delay: 20,
    name: "en to tre",
    isPresent: true,
    delay: 50
};

We can modify an object created in this way by, among other things, adding new properties.(dot notation)
sampleObject.newkey= value

The key is a string. When creating an object, the key can be enclosed in quotation marks, although this is not necessary 
(JavaScript automatically interprets it as a string). However,this can be useful when you want to create a key consisting of several words. For example, 
the following construction will be wrong:
//error
let contact = {
	first name: "Ronald"
};
//correct
let contact = {
    "first name": "Ronald"
};

However, giving keys names consisting of many separate words is not the best idea.

If you need a multi-word name, it’s better to use, for example, the Camel case notation, and write firstName instead of "first name". 
The notation will be both more readable to the user and less burdensome on the computer. With multi-word keys, 
it will also be a problem to refer to the property of an existing object – dot notation does not allow it.
bracket notation is the solution for this
the object property does not have to be of the number, Boolean, or string type. It could as easily be an array, an object, or a ... function. 
*************Deleting objects************
The JavaScript engine uses a Garbage Collector, which decides for us whether the objects are still needed, and possibly removes them.

The JavaScript language doesn’t even provide for the possibility of explicitly deleting objects.

**************Properties*********************
---------Types : 
As we mentioned earlier, we can assign primitive values to variables (e.g. number, Boolean, or string), complex values such as arrays or objects, and functions.
let test = {
nr: 10, 
b: false, 
str: "uno dos tres", 
arr: [10, 20, 30], 
obj: {
x: 10, 
y: 20
}, 
fn: function(arg) {console.log(arg)} 
};

test.fn(123);

----------Nested properties : 
If the property of an object is another object that has properties itself, then we are dealing with nested properties.
Referring to such fields using dot notation is intuitive, and we simply add another dot and key (property name).
console.log(test.obj.x);
test.obj.y = 40;
-----------A function as a property type – a method
A function that is the property of an object will be called a method.
Just as the properties of objects describe their characteristics, methods can be treated as their characteristic behavior, or ways of changing the state of an object.

let point = {
x: 0,
y: 0,
moveHorizontally: function(distance) {
    this.x = this.x + distance;
},
moveVertically: function(distance) {
    this.y = this.y + distance;
}
}

console.log(point.x);	// -> 0
point.moveHorizontally(30);
console.log(point.x);	// -> 30

The method does not have to affect the state of the object, but this is essentially one of the main reasons for their use.

----------------Adding a new property

The changes concern not only the values stored in specific fields, but also all the properties that we can add or delete, and the type of data placed in them that we can change.

let contact = {
    tel: "207-662-5412",
    email: "RonaldSMurphy@freepost.org"
};
contact.firstName = "Ronald";
contact.lastName = "Murphy";
console.log(contact.tel);   // -> 207-662-5412
console.log(contact.firstName);     // -> Ronald

By the way, try to display a non-existent property, such as a notes. Note that a non-existent property of an object is treated as undefined and not, for example, as null.(no referernce error)

----------------Modifying a property

By default, there are no restrictions on modifying the values placed in object properties (we’ll talk about non-writable properties in the chapter on configuring object properties).

Thus, we can assign a new value of any type to an existing object property at any time – we are not limited by the previous value type.
contact.email = ["RonaldSMurphy@freepost.org", "rsmurphy@briazz.com" ];

-------------------Deleting a property
delete contact.email.work;
--------------------Dot notation vs. bracket notation
his method is similar to referencing an array field, except that we don't give the index of an element, but instead we give its key. Remember, the key is a string!

contact.tel === contact["tel"];
contact.email.work === contact["email"]["work"]
Multi-word keys => use Bracket notation

-----------------Computed keys
However, bracket notation is more often used when operating on computed keys.

It may happen that the property key we want to refer to will be calculated during the operation of the program, on the fly.

In this case, dot notation will not allow us to combine the object name and calculated key (e.g. stored in a variable).
let contact = {
    email_1: "RonaldSMurphy@freepost.org",
    email_2: "rsmurphy@briazz.com"
};
for(i=1; i<=2; i++) {
    let key = "email_" + i;  //computed key
    console.log(key);
    console.log(contact[key]);

---------------Property existence test and property enumeration
If you try to read a non-existent property, the undefined value will be returned.

JavaScript will behave the same if the field exists but has no value assigned to it.
In most cases, it won’t matter to us whether a field does or does not exist, or simply has no value assigned to it.

Both cases are handled in the same way, with a new value being assigned to the property (if the field does not exist, it will automatically be created).
if(contact.notes) { // if different then undefined
    console.log(contact.notes);
}
 This can have fatal consequences, especially for nested objects.
 console.log(contact.notes); // -> undefined  program continue to work 
 console.log(contact.email.private); // exception! (use try catch)
 
The easiest way to protect yourself is to either use the try ... catch block, or simply check before calling if the object and required field exist:
if(contact && contact.email) {
    console.log(contact.email.private);
}

or 
contact && contact.email && console.log(contact.email.private);

-----------Existence test using "in"
If the field exists, it’s returned true (even if the field has no set value).
if("notes" in contact) { // if true
    console.log(contact.notes);
}
------------Enumeration "for ... in"

Using for ... in, we can go through the properties of an object (with some limitations, which we’ll talk about in the chapter on the configuration of properties).
To get to the value of a given field, we use bracket notation (the key is dynamically calculated and placed in the variable, so we cannot use dot notation).


--------The Object.keys method 
This method returns an array of property names, which we can use in any way we want.
let keys = Object.keys(contact);
